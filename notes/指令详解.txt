directive() 这个方法是用来定义指令的:
	angular.module('myApp', [])
		.directive('myDirective', function ($timeout, UserDefinedService) {
		// 指令定义放在这里
	});
directive() 方法可以接受两个参数：
	1.  name （字符串）
		指令的名字，用来在视图中引用特定的指令。
	2.  factory_function （函数）
		这个函数返回一个对象， 其中定义了指令的全部行为。 $compile 服务利用这个方法返回的对
		象，在DOM调用指令时来构造指令的行为。
			angular.application('myApp', [])
				.directive('myDirective', function() {
					// 一个指令定义对象
					return {
					// 通过设置项来定义指令，在这里进行覆写
					};
			});
		我们也可以返回一个函数代替对象来定义指令，但是像上面的例子一样，通过对象来定义是
		最佳的方式。

定义一个指令时可以使用的设置选项
	1. restrict
		restrict 是一个可选的参数。它告诉AngularJS这个指令在DOM中可以何种形式被声明。默
		认AngularJS认为 restrict 的值是 A ，即以属性的形式来进行声明
	2. terminal
		是一个布尔型参数，可以被设置为 true 或 false
		这个参数用来告诉AngularJS停止运行当前元素上比本指令优先级低的指令。但同当前指令
		优先级相同的指令还是会被执行
	3. replace
		可选参数，如果设置了这个参数，值必须为 true ，因为默认值为 false 。
		默认值意味着模板会被当作子元素插入到调用此指令的元素内部

指令作用域
	scope参数
		可选的，可以被设置为 true 或一个对象。默认值是 false
		当 scope 设置为 true 时，会从父作用域继承并创建一个新的作用域对象
	隔离作用域
		创建具有隔离作用域的指令需要将 scope 属性设置为一个空对象 {}
		如果这样做了，指令的模板就无法访问外部作用域了

绑定策略：
	让新的指令作用域可以访问当前本地作用域中的变量，可以使用三种别名中的一种：
		本地作用域属性：使用 @ 符号将本地作用域同DOM属性的值进行绑定。
						指令内部作用域可以使用外部作用域的变量
						@ (or @attr)
						现在，可以在指令中使用绑定的字符串了
		双向绑定：通过 = 可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定
				  就像普通的数据绑定一样，本地属性会反映出父数据模型中所发生的改变
				  = (or =attr)
		父级作用域绑定：通过 & 符号可以对父级作用域进行绑定，以便在其中运行函数
						意味着对这个值进行设置时会生成一个指向父级作用域的包装函数
						要使调用带有一个参数的父方法，我们需要传递一个对象，这个对象的键是参数的名称，值
						是要传递给参数的内容
						& (or &attr)